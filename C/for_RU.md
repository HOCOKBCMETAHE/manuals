# While цикл

Здесь собрана информация по работе с циклом while в языке программирования C

Информация для перевода взята с сайта [devdocs](https://devdocs.io/c)

Перевел [Egor Kondratov](https://github.com/mavissig)

### Связанные статьи:
- [while](./while_RU.md)
- [do-while](./do-while_RU.md)

### Содержание
- [Кратко про for](#кратко-про-for)
- [Синтаксис](#синтаксис)
- [Объяснение](#объяснение)
- [Пример](#пример)

<img src="./materials/pre_for.png" width="100%">

---

## Кратко про for

Выполняет цикл.

Используется как более краткий эквивалент цикла [while](./while_RU.md).

---

## Синтаксис

    for (init-clause ; cond-expression ; iteration-expression) {
        ...
        loop-statement
        ...
    }

- `init-clause` - инициализация 
- `cond-expression` - условное-выражение 
- `iteration-expression` - выражение итерации

---

## Объяснение

Поведение следующее:

- `init-clause` может быть выражением или объявлением (начиная с C99).

    - Если `init-clause` - это выражение, оно вычисляется один раз перед первым вычислением `cond-expression`, и его результат отбрасывается.

    - Если `init-clause` - это объявление, оно находится в области видимости 
    во всем теле цикла, включая оставшуюся часть `init-clause`, всё 
    `cond-expression`, всю `iteration-expression` и всё тело цикла. Для 
    переменных, объявленных в этом объявлении, разрешены только хранилища 
    auto и register. (начиная с C99)

- `cond-expression` вычисляется перед телом цикла. Если результат выражения равен нулю, выполнение цикла прекращается немедленно.

- `iteration-expression` вычисляется после выполнения тела цикла, и её результат отбрасывается. После вычисления `iteration-expression` управление передается к `cond-expression`.

`init-clause`, `cond-expression` и `iteration-expression` - все они необязательны. Если `cond-expression` опущено, оно заменяется на ненулевую целочисленную константу, делая цикл бесконечным:

    for(;;) {
        printf("endless loop!");
    }

Тело цикла(loop-statement) обязателен, но может быть пустым оператором (null statement):

    for(int n = 0; n < 10; ++n, printf("%d\n", n)); 
        // null statement

Если выполнение цикла нужно прервать в какой-то момент, можно использовать оператор break в любом месте внутри тела цикла.

Оператор continue, использованный в любом месте внутри тела цикла, передает управление в `iteration-expression`.

Программа с бесконечным циклом имеет неопределенное поведение, если в `cond-expression`, `iteration-expression` или `теле цикла (loop-statement)` нет наблюдаемого поведения (ввода-вывода, доступа к волатильным переменным, атомарных или синхронизационных операций). Это позволяет компиляторам оптимизировать все ненаблюдаемые циклы без необходимости доказательства их завершаемости. Единственные исключения - циклы, в которых `cond-expression` опущено или является константным выражением. 

`for(;;)` - всегда бесконечный цикл.

Как и с любыми другими операторами выбора и итерации, оператор for создает блочную область видимости: любой идентификатор, введенный в `init-clause`, `cond-expression` или `iteration-expression`, выходит из области видимости после `тела цикла (loop-statement)`.

### Примечание

Оператор выражения, используемый как `loop-statement`, создает свою собственную область видимости блока, отличную от области видимости `init-clause`, в отличие от C++.

    for (int i = 0; ; ) {
        long i = 1;   // valid C, invalid C++
        // ...
    }

Возможно войти в тело цикла с использованием оператора goto. При входе в цикл таким образом, `init-clause` и `cond-expression` не выполняются. (Если управление затем достигает конца тела цикла, повторение может произойти, включая выполнение `cond-expression`).

---

## Пример

    #include <stdio.h>
    #include <stdlib.h>
    enum { SIZE = 8 };
    int main(void)
    {
        int array[SIZE];
        for(size_t i = 0 ; i < SIZE; ++i)
            array [i] = rand() % 2;
        printf("Array filled!\n");
        for (size_t i = 0; i < SIZE; ++i)
            printf("%d ", array[i]);
        putchar('\n');
    }

Output:

    Array filled!
    1 0 1 1 1 1 0 0


---
---